+++
title = "Текстовый режим VGA"
weight = 2
path = "ru/vga-text-mode"
date = 2018-02-26

[extra]
chapter = "С нуля"
translators = ["MrZloHex"]
+++

[Текстовый режим VGA][VGA text mode] &mdash; это простой способ вывода текста на экран. В этом посте мы создадим интерфейс, который делает его использование безопасным и простым, инкапсулируя все уязвимости в отдельный модуль. Мы также реализуем поддержку [макросов форматирования][formatting macros] языка Rust.

[VGA text mode]: https://en.wikipedia.org/wiki/VGA-compatible_text_mode
[formatting macros]: https://doc.rust-lang.org/std/fmt/#related-macros

<!-- more -->

Этот блог открыто разрабатывается на [GitHub]. Если у вас возникли какие-либо проблемы или вопросы, пожалуйста, создайте _issue_. Также вы можете оставлять комментарии [в конце страницы][at the bottom]. Полный исходный код для этого поста вы можете найти в репозитории в ветке [`post-03`][post branch].

[GitHub]: https://github.com/phil-opp/blog_os
[at the bottom]: #comments
[post branch]: https://github.com/phil-opp/blog_os/tree/post-03

<!-- toc -->

## Текстовый буфер VGA

Чтобы вывести символ на экран в текстовом режиме VGA, необходимо записать его в текстовый буфер аппаратного обеспечения VGA. Текстовый буфер VGA представляет собой двумерный массив с типичными 25 строками и 80 столбцами, который непосредственно выводится на экран. Каждая запись массива описывает один экранный символ в следующем формате:

 Биты  | Значения
------ | --------------------
0-7    | ASCII Кодовая точка 
8-11   | Цвет переднего плана   
12-14  | Цвет фона
15     | Мигание

Первый байт представляет символ, который должен быть напечатан в [кодировке ASCII][ASCII encoding]. Точнее говоря, это не совсем ASCII, а набор символов [_кодовая страница 437_][_code page 437_] с некоторыми дополнительными символами и небольшими модификациями. Для простоты в этой заметке мы будем называть его символом ASCII.

[ASCII encoding]: https://en.wikipedia.org/wiki/ASCII
[_code page 437_]: https://en.wikipedia.org/wiki/Code_page_437

Второй байт определяет способ отображения символа. Первые четыре бита определяют цвет переднего плана, следующие три бита &mdash; цвет фона, а последний бит &mdash; должен ли символ мигать. Доступны следующие цвета:

Номер  | Цвет         | Номер + Бит Яркости | Яркий Цвет
------ | ------------ | ------------------- | -------------
0x0    | Черный       | 0x8                 | Темно-серый
0x1    | Синий        | 0x9                 | Светло-синий
0x2    | Зеленый      | 0xa                 | Светло-зеленый
0x3    | Голубой      | 0xb                 | Светло-голубой
0x4    | Красный      | 0xc                 | Светло-красный
0x5    | Пурпурный    | 0xd                 | Розовый
0x6    | Коричневый   | 0xe                 | Желтый
0x7    | Светло-серый | 0xf                 | Белый

Бит 4 &mdash; это _бит яркости_, который превращает, например, синий цвет в светло-синий. Для цвета фона этот бит перепрофилируется в бит мигания.

Текстовый буфер VGA доступен через [отображение ввода-вывода на памяти][memory-mapped I/O] по адресу `0xb8000`. Это означает, что при чтении и записи по этому адресу доступ осуществляется не к оперативной памяти, а непосредственно к текстовому буферу VGA. Это означает, что мы можем читать и записывать его через обычные операции с памятью по этому адресу.

[memory-mapped I/O]: https://en.wikipedia.org/wiki/Memory-mapped_I/O

Обратите внимание, что оборудование с отображением на память может не поддерживать все обычные операции с оперативной памятью. Например, устройство может поддерживать только побайтовое чтение и возвращать мусор при чтении `u64`. К счастью, текстовый буфер [поддерживает обычное чтение и запись][supports normal reads and writes], так что нам не придется обращаться с ним особым образом.

[supports normal reads and writes]: https://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#manip